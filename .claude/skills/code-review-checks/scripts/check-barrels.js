#!/usr/bin/env node
/**
 * Checks for directories missing barrel (index.ts) files.
 *
 * @example
 * node check-barrels.js --path src/
 * node check-barrels.js --path src/ --generate
 */

import { readFileSync, existsSync, readdirSync, writeFileSync } from 'fs';
import { join, relative, resolve, basename } from 'path';

/**
 * Parse command line arguments
 */
function parseArgs() {
  const args = process.argv.slice(2);
  const result = {
    path: 'src/',
    generate: false,
    minFiles: 2,
    verbose: false
  };

  for (let i = 0; i < args.length; i++) {
    switch (args[i]) {
      case '--path':
        result.path = args[++i];
        break;
      case '--generate':
        result.generate = true;
        break;
      case '--min-files':
        result.minFiles = parseInt(args[++i], 10);
        break;
      case '--verbose':
      case '-v':
        result.verbose = true;
        break;
    }
  }
  return result;
}

/**
 * Get exported symbols from a TypeScript file
 */
function getExports(filePath) {
  const content = readFileSync(filePath, 'utf-8');
  const exports = {
    functions: [],
    types: [],
    interfaces: [],
    classes: [],
    consts: [],
    enums: []
  };

  const lines = content.split('\n');
  for (const line of lines) {
    // Export function
    let match = line.match(/^export\s+(async\s+)?function\s+(\w+)/);
    if (match) {
      exports.functions.push(match[2]);
      continue;
    }

    // Export const/let
    match = line.match(/^export\s+const\s+(\w+)/);
    if (match) {
      exports.consts.push(match[1]);
      continue;
    }

    // Export type
    match = line.match(/^export\s+type\s+(\w+)/);
    if (match) {
      exports.types.push(match[1]);
      continue;
    }

    // Export interface
    match = line.match(/^export\s+interface\s+(\w+)/);
    if (match) {
      exports.interfaces.push(match[1]);
      continue;
    }

    // Export class
    match = line.match(/^export\s+class\s+(\w+)/);
    if (match) {
      exports.classes.push(match[1]);
      continue;
    }

    // Export enum
    match = line.match(/^export\s+enum\s+(\w+)/);
    if (match) {
      exports.enums.push(match[1]);
      continue;
    }
  }

  return exports;
}

/**
 * Generate barrel file content for a directory
 */
function generateBarrel(dir) {
  const entries = readdirSync(dir, { withFileTypes: true });
  const tsFiles = entries.filter(
    e => e.isFile() && e.name.endsWith('.ts') && e.name !== 'index.ts' && !e.name.includes('.test.') && !e.name.includes('.spec.')
  );

  const lines = [
    '/**',
    ' * Barrel file - exports public API for this module.',
    ' * Auto-generated by check-barrels.js',
    ' */',
    ''
  ];

  for (const file of tsFiles) {
    const filePath = join(dir, file.name);
    const moduleName = file.name.replace('.ts', '.js');
    const exports = getExports(filePath);

    const allExports = [
      ...exports.functions,
      ...exports.consts,
      ...exports.classes,
      ...exports.enums
    ];

    const typeExports = [
      ...exports.types,
      ...exports.interfaces
    ];

    if (allExports.length > 0) {
      lines.push(`export { ${allExports.join(', ')} } from './${moduleName}';`);
    }

    if (typeExports.length > 0) {
      lines.push(`export type { ${typeExports.join(', ')} } from './${moduleName}';`);
    }
  }

  // Also re-export from subdirectories with index.ts
  const subDirs = entries.filter(
    e => e.isDirectory() && !e.name.startsWith('.') && e.name !== 'node_modules' && e.name !== '__tests__'
  );

  for (const subDir of subDirs) {
    const indexPath = join(dir, subDir.name, 'index.ts');
    if (existsSync(indexPath)) {
      lines.push(`export * from './${subDir.name}/index.js';`);
    }
  }

  return lines.join('\n') + '\n';
}

/**
 * Check directories for missing barrels
 */
function checkDir(dir, options, results = []) {
  if (!existsSync(dir)) return results;

  const entries = readdirSync(dir, { withFileTypes: true });
  const tsFiles = entries.filter(
    e => e.isFile() && e.name.endsWith('.ts') && e.name !== 'index.ts' && !e.name.includes('.test.') && !e.name.includes('.spec.')
  );
  const hasIndex = entries.some(e => e.isFile() && e.name === 'index.ts');
  const subDirs = entries.filter(
    e => e.isDirectory() && !e.name.startsWith('.') && e.name !== 'node_modules' && e.name !== '__tests__'
  );

  // Check if this directory needs a barrel
  if (tsFiles.length >= options.minFiles && !hasIndex) {
    results.push({
      dir: relative(process.cwd(), dir) || '.',
      files: tsFiles.map(f => f.name),
      content: options.generate ? generateBarrel(dir) : null
    });
  }

  // Recurse into subdirectories
  for (const subDir of subDirs) {
    checkDir(join(dir, subDir.name), options, results);
  }

  return results;
}

/**
 * Main entry point
 */
function main() {
  const options = parseArgs();
  const results = checkDir(resolve(options.path), options);

  if (results.length === 0) {
    console.log('\n[PASS] All directories have barrel files!\n');
    return;
  }

  console.log('\n=== Missing Barrel Files ===\n');

  for (const result of results) {
    console.log(`${result.dir}/`);
    console.log(`  Files: ${result.files.join(', ')}`);

    if (options.generate && result.content) {
      const indexPath = join(result.dir, 'index.ts');
      writeFileSync(indexPath, result.content);
      console.log(`  [CREATED] ${indexPath}`);
      if (options.verbose) {
        console.log('  Content:');
        console.log(result.content.split('\n').map(l => '    ' + l).join('\n'));
      }
    }
    console.log('');
  }

  if (!options.generate) {
    console.log(`Found ${results.length} directories missing barrel files.`);
    console.log('Run with --generate to create them automatically.\n');
  } else {
    console.log(`Created ${results.length} barrel files.\n`);
  }
}

main();
